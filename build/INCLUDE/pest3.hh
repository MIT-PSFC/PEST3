#ifndef __pest3__
#define __pest3__

/* Pest3 class. A. Pletzer Feb-23-2000
   From various equilibrium file formats compute the
   Delta' stability 

   put in widmsh and alfmsh vector input options, and edge packing with standard
   zone, and optional power law in the edge zone for the peeling mode DPB 2/10

   put in packpts setting option to increase number of symmetric points around
   a surface. DPB 5/10
*/

#include <string>
using std::string;

#include <iostream>
#include <cstdlib>
#include <cmath>
#include "ezcdf.hh"

const int pest3_kmax = 10; // max no of convergence runs
const int pest3_msinmax = 10; // max no rational surfaces
const int pest3_wsinmax =  pest3_msinmax+2 ; // max no mesh packs (+axis+edge)
const int pest3_asinmax =  2 ; // max no of alfas specified (axis+edge)
const int pest3_nosingmax = 10; // max no of singular surfaces

/* PEST3 access routines */

extern "C" {

#include "pest3_api.h"

}

const string pest3_inputError     = "--Pest3 Input Error--";
const string pest3_execError      = "--Pest3 Execution Error--";
const string pest3_unknownError   = "--Pest3 Unknown Error--";

class pest3Error{
public:
  pest3Error(string mes){
     std::cout << mes.c_str() << std::endl;
  }
};

class pest3 {
public:
  int nErrors;
  string execName;
  int ms; /* resonant poloidal mode */
  int n ; /* toroidal mode */
  int mm[pest3_kmax]; /* number of radial nodes */
  int msin[pest3_msinmax]; /* singular surface selector */
  int msin_len; /* actual size of msin */
  int lmax1; /* Fourier modes -lmax1, ..., lmax1 */
  double b; /* wall distance from magnetic axis is  a*(1+b) */
  double newQ; /* new safety factor value at edge, or if negative on axis */
  int mesh; /* set this to zero to get packed mesh */
  int inputFormat; /*-1=input from binary file INP1 generated by CHEASE
		      0=input TRANSP UFILE
		      1=input from netCDF file inp1.cdf generated by CHEASE
		      2=input from netCDF file eqdsk.cdf generated by JSOLVER 
		      3=input from G-EQDSK file 
		      4=input from G-EQDSK file thru ESC-Q
		      5= Menard's psipqgRZ format in MKS (netCDF)
		      6= Belova's freeqbe format (netCDF)
                      8= input from binary file generated by
                        L. Don Pearlstein's inverse equilibrium code
	      ... other 
		*/
  
  int np1; // no of poloial points + 1 (directed equilibrium input only)
  int nr; // no of radial points (directed equilibrium input only)
  int akima; // =1 if Jacobian should be Akima splined.
  double separatrix; // How close to the separatrix (directed equilibrium input only)?
  double x2axis; // By how much should some profles be extrapolated to the axis.
  double x2edge; // By how much should some profles be extrapolated to the edge.


  int nosurf, mth;

  int nosing;

  double majorRadius, minorRadius, TroyonG, betaPoloidal, betaToroidal;
  double fourPiInductance, totalToroidalCurrent, elongation, triangularity;
  double rMagnetic, b0SquareCentre;
  double mu[pest3_nosingmax];
  double dr[pest3_nosingmax];
  double qs[pest3_nosingmax];
  double q0, qmin, qa, qmax;
  double psi0, psia;
  double psis[pest3_nosingmax];
  double re_deltap[pest3_nosingmax][pest3_nosingmax];
  double im_deltap[pest3_nosingmax][pest3_nosingmax];
  double err_deltap[pest3_nosingmax][pest3_nosingmax];
  double err_gamtap[pest3_nosingmax][pest3_nosingmax];
  double re_gamtap[pest3_nosingmax][pest3_nosingmax];
  double im_gamtap[pest3_nosingmax][pest3_nosingmax];
  int nIdealInstabilities;
  int solver;
  double wLambda;
  double dlayb;
  double dlay;
  int lsymhi;
  double betmsh;
  double widmsh[pest3_wsinmax]; 
  double alfmsh[pest3_wsinmax]; /* alfmsh has as many elements as widmsh, but   
                                   the vector read in can only be two long,   
                                   because it can only be specified on axis
                                   and edge. */
  int packpts[pest3_wsinmax]; 
  int wsin_len; /* actual size of widmsh */
  int asin_len; /* actual size of alfmsh */
  int packmth; /* integer selector of grid packing method.  */
  int pkin_len; /* actual size of packpts */
  string inputPath; // Can be MDSPLus path,...
  double equilTime;
  int inputPath_len;
  // factor to convert Delta' from psi to minor radius r
  double rdpdr[pest3_nosingmax]; 
  // next order term in large Frobenius expansion in zero beta limit
  double lambdas[pest3_nosingmax]; 
  
  /* c'tor */
  pest3(){

  int i;

  nErrors=0;
  ms = 3;
  n  = 2;
  for(i=1; i<pest3_kmax; i++) mm[i] = 0;
  mm[0]  = 100;

  for(i=1; i<pest3_msinmax; i++) msin[i] = 0;
  msin[0] = ms;

  msin_len=1;
  wsin_len=1;
  asin_len=1;
  pkin_len=1;
  lmax1 = 10;
  b = 0.0;
  newQ = 0.0;
  mesh = 0;
  inputFormat = +1;

  akima = 0;
  np1 = 129;
  nr = 201;
  separatrix = 0.9999;
  x2axis = 0.01;
  x2edge = 0.00;

  nosurf = 0;
  mth = 0;
  q0 = 0.0;
  qmin = 0.0;
  qa = 0.0;
  qmax = 0.0;
  psi0 = 0.0;
  psia = 0.0;
  nIdealInstabilities = 0;
  majorRadius = 0.0;
  minorRadius = 0.0;
  TroyonG = 0.0;
  betaPoloidal = 0.0;
  betaToroidal = 0.0;;
  fourPiInductance = 0.0;
  totalToroidalCurrent = 0.0;
  elongation = 0.0;
  triangularity = 0.0;
  rMagnetic = 0.0;
  b0SquareCentre = 0.0;
//    mjac = 2;
//    njac = 0;
  solver =0;
  wLambda = 0.0;
  dlayb = 0.9; 
  dlay  = 0.005; 
  lsymhi = 0;
  betmsh = 1.0;
  alfmsh[0] = 2.0;
  for(i=1; i<pest3_wsinmax; i++) alfmsh[i] = 1.0;
  for(i=0; i<pest3_wsinmax; i++) widmsh[i] = 0.05;
  for(i=0; i<pest3_wsinmax; i++) packpts[i] = 1;
  packmth=0;
  inputPath = "inp1.cdf";
  inputPath_len = (int)inputPath.length();
  equilTime = 0.0;

  //mu = 0.0;
  //dr = 0.0;
  //rdpdr = 0.0; 
  //lambdas = 0.0; 
  //psis = 0.0;
//   re_deltap = 0.0;
//   im_deltap = 0.0;
//   err_deltap = 0.0;
//   re_gamtap = 0.0;
//   im_gamtap = 0.0;
//   err_gamtap = 0.0;
  }

  /* d'tor */
  ~pest3(){
  }

  void usage(void);      
  int parseArgs(int narg, char *argv[]);
  int checkArgs(void);
  int isQsInPlasma(void);
  int run(void);
  
};


  void pest3::usage(void){
    std::cout << "Usage: pest3 [Options]\n";
    std::cout << "Options:\n";
    std::cout << "-n<ns> Set the toroidal mode number (2)\n";
    std::cout << "-m<ms> Set the resonant poloidal mode (3). Alternatively, \n";
    std::cout << "\t the user can also give a string of the form \"..x.x\" to \n";
    std::cout << "\t specify the rational surfaces where the Delta' are to be \n";
    std::cout << "\t computed: an 'x' for a selected surface and a '.' for surfaces\n";
    std::cout << "\t that should be skipped. Each symbol ('.' or 'x') corresponds\n";
    std::cout << "\t to a surface where ns*q is an integer, counting from the axis.\n";
    std::cout << "-k<Ns> Set number of radial finite elements (100)\n";
    std::cout << "\t To perform a convergence study type -k\"Ns1 Ns2 ...\" where\n";
    std::cout << "\t Ns1, Ns2, .. are a range of radial number of finite elements.\n";
    std::cout << "\t The matching data so obtained are the extrapolation to inifinte\n";
    std::cout << "\t resolution (Ns->oo) and an estimate of the finite element error\n";
    std::cout << "\t is returned assuming a convergence in 1/Ns^2. Note that that the \n";
    std::cout << "\t Frobebius coefficients of the large solution are only computed\n";
    std::cout << "\t once, for Ns1. A typical choice is -k\"100 70 140 200\".\n";
    std::cout << "-l<Lmax1> Poloidal Fourier modes span -|Lmax1|,...+|Lmax1| (10)\n";
    std::cout << "-b<Bw> Relative wall distance from plasma surface normalized to \n";
    std::cout << "\t minor radius (0). For instance -b0.2 for wall position at 1.2\n";
    std::cout << "\t times minor radius. Bw=0 is wall on plasma surface whereas Bw>=10 is\n";
    std::cout << "\t wall at infinity.\n";
    std::cout << "-S     Symmetric large solution support. Default is asymmetric.\n";
    std::cout << "\t This option is typically used for higher m modes, which tend to \n";
    std::cout << "\t be localized about their resonant surface\n";
    std::cout << "-d<rw> Relative extension of large solution to neighboring rational\n";
    std::cout << "\t surfaces (0.9). Must have 0.05 < rw < 0.99. If -S is in addition\n";
    std::cout << "\t selected, then rw is the smallest of the distance between the left\n";
    std::cout << "\t and right rational surfaces. \n";
/*  std::cout << "-e<eb> For packing near plasma edge set eb > 1.0 (1.0).\n";*/
    std::cout << "-i<if> Format (1). Possible values are:\n";
    std::cout << "\t-1 read binary equilibrium input file (INP1) from CHEASE\n";
    std::cout << "\t 0 input equilibrium from TRANSP Ufiles (local or MDS+)\n";
    std::cout << "\t 1 read netCDF equilibrium input file (inp1.cdf) from CHEASE\n";
    std::cout << "\t 2 read netCDF equilibrium input file (eqdsk.cdf) from JSOLVER\n";
    std::cout << "\t 3 read G-EQDSK equilibrium input file from EFIT. This can also\n";
    std::cout << "\t   be an MDSPlus path, for instance:\n";
    std::cout << "\t   MDS+/REDUCE:BIRCH.PPPL.GOV:8501:EFIT01(103984;t=0.23)\n";
    std::cout << "\t 4 read G-EQDSK equilibrium input file from EFIT and rerun thru\n";
    std::cout << "\t   ESC-Q. Can also be an MDSPlus path (see above).\n";
    std::cout << "\t 5 read Menard netCDF input file in psipqgRZ MKS format\n";
    std::cout << "\t 6 read Belova netCDF input file format (freeqbe)\n";
    std::cout << "\t 8 read L. Don Pearlstein's inverse equilibrium file \n";
    std::cout << "-f<File> Read equilibrium data from <File>. <File> can be a local \n";
    std::cout << "\t netCDF file (e.g. inp1.cdf) or, if MDSPlus access has been enabled\n";
    std::cout << "\t a path such as: MDS+:TRANSPGRID.PPPL.GOV:TRANSP(TFTR.88,37065Y82)\n";
    std::cout << "-T<time> Set MDSPlus equilibrium time to <time> in [sec] (0). \n";
    std::cout << "\t Will correct to the min/max value if selected <time> is outside \n";
    std::cout << "\t interval.\n";
    std::cout << "-q<newQ> Rescale equilibrium by adjusting the safety factor q=newQ\n";
    std::cout << "\t at the plasma edge. If negative, then set q on axis to abs(newQ).\n";
    std::cout << "\t Leave equilibrium unchanged if newQ=0 (default).\n";
    std::cout << "-s<is> Solver (0). Possible values are:\n";
    std::cout << "\t 0 use PEST3's built-in linear system solver\n";
    std::cout << "\t 1 compute lowest delta-W eigenvalue using LAPACK routine\n";
    std::cout << "-u     Uniform radial mesh. Default is mesh packing about rational surfaces.\n";
    std::cout << "\t In general, automatic mesh packing is desirable. This option is useful\n";
    std::cout << "\t at high finite element resolution by preventing the clutering of nodes\n";
    std::cout << "\t about the resonant surface.\n";

    std::cout << "-a<xa> Extrapolate some profiles over distance xa to axis (0.01)\n";
    std::cout << "-x<xe> Extrapolate some profiles over distance xe to edge (0.00)\n";
    
    std::cout << "-P<p1> Use p1 poloidal rays for mapping (129)(direct equilibrium only).\n";
    std::cout << "-R<rs> Use rs radial surfaces for mapping (401)(direct equilibrium only).\n";
    std::cout << "-E<ed> Separatrix retreat factor (0.999) (direct equilibrium only).\n";

    std::cout << "-A     Akima spline Jacobian and friends (default is Jacobian derived\n";
    std::cout << "\t from X and Z).\n";
    std::cout << "-M<mth> Set the packing method (0).\n";
    std::cout << "\t 0 Standard with axis, surfaces and edge packed.\n";
    std::cout << "\t Standard zones are either left default or set with widmsh and alfmsh\n";
    std::cout << "\t input.  See widmsh and alfmsh. \n";
    std::cout << "\t 1 Edge packing with power law dzx/dz=a*(c0-zx)^alfa. This can resolve\n";
    std::cout << "\t the peeling mode very near the separatrix.  Power alfa is set with\n";
    std::cout << "\t alfmsh.\n";
    std::cout << "-p<as> For packing at edge and boundary set alfmsh vector via \n";
    std::cout << "\t -p\"a0 a1\" where a0 is the axis packing power and a1 is the \n";
    std::cout << "\t edge packing power, with both >=1.0 (1.0).  Surfaces are packed\n";
    std::cout << "\t with alpha(mu) at the surface if packing is turned on.\n";
    std::cout << "\t A value of 1.0 produces no packing.  If one number is entered\n";
    std::cout << "\t the axis and edge both get that alfmsh.\n";
    std::cout << "-K<pkpts> Set the packpts vector for the surfaces, pkpts\n";
    std::cout << "\t via -K\"p1 p2 ... \".  If one number is entered then all packing \n";
    std::cout << "\t locations get that p1. The number of entries can also be the the \n";
    std::cout << "\t number of resonant surfaces in mm (no axis and edge numbers).\n";
    std::cout << "\t These entries should be in the same order as mm, from axis to\n";
    std::cout << "\t edge, with the first surface packpts always coming first.\n";
    std::cout << "-W<ws> Set the widmsh vector for the surfaces, axis and edge with ws \n";
    std::cout << "\t via -W\"w1 w2 ... \".  For packing method -M0 or 1: widmsh is the \n"; 
    std::cout << "\t width that each surface takes up in grid index space (0-1) for \n";
    std::cout << "\t packing.  If one number is entered then all packing locations get \n";
    std::cout << "\t that widmsh. The number of entries can also be the number of \n";
    std::cout << "\t resonant surfaces in mm plus 2 for the axis and edge. These entries \n";
    std::cout << "\t should be in the same order as mm, from axis to edge, with the axis \n";
    std::cout << "\t widmsh always coming first.\n";
    std::cout << "\t For packing method -M2: widmsh is the location of each surface in \n";
    std::cout << "\t grid index space (0-1).  The number of entries MUST be the number \n";
    std::cout << "\t of resonant surfaces in mm plus 2 for the axis and edge. These entries\n";
    std::cout << "\t should be in the same order as mm, from axis to edge, with the axis \n";
    std::cout << "\t widmsh always coming first.i  The axis and edge values should always \n";
    std::cout << "\t be 0 and 1 respectively.\n";

    
    std::cout << "-h     This message.\n"; 
  }        

  int pest3::parseArgs(int narg, char *argv[]){
   int j, flag_loc, k, i;

    execName = string(argv[0]);
    for (i=1; i<narg; i++){
      switch(argv[i][1]){
    case 'm':
       if(isdigit(argv[i][2])) {
	// if a number then must be resonant m
	ms = atoi(&argv[i][2]);
	msin[0] = ms;
	msin_len = 1;
	// msin set later
       } else {
 	// user knows where the resonant surfaces are, and
 	// uses a string format: eg ".**." 
 	ms = 0;
 	j = 2;
 	msin_len = 0;
 	while (argv[i][j] != '-' && argv[i][j] != '\0' && 
 	       msin_len < pest3_msinmax){
	  if(argv[i][j] == '"') continue;
 	  msin[msin_len] = 1;
 	  if(argv[i][j] == '.') {
	    msin[msin_len] = 0;
	    std::cout << " Rational surface no. " << j-1 << " will be skipped\n";
	  } else {
	    std::cout << " Rational surface no. " << j-1 << " will be added\n";
	  }
 	  msin_len++;
 	  j++;
 	}
      }
      break;
    case 'n':
      n = atoi(&argv[i][2]);
      break;
    case 'k':
     mm[0] = atoi(&argv[i][2]);
     j = 2;
     k = 0;
     flag_loc = 1;
     while (argv[i][j] != '-' && argv[i][j] != '\0'){
	if(flag_loc==0 && argv[i][j]==' ') flag_loc=1;
	if(flag_loc==1 && argv[i][j]!=' ' && k<pest3_kmax){
	  mm[k] = atoi(&argv[i][j]);
	  flag_loc = 0;
	  k++;
	}
	j++;
     }  
      break;
    case 'l':
      lmax1 = atoi(&argv[i][2]);
      break;
    case 'b':
      b = atof(&argv[i][2]);
      break;
/*    case 'e':
      betmsh = atof(&argv[i][2]);
      break;*/
    case 'd':
      dlayb = atof(&argv[i][2]);
      break;
    case 'D':
      dlay = atof(&argv[i][2]);
      break;
    case 'S':
      lsymhi = 1;
      break;
    case 'i':
      inputFormat = atoi(&argv[i][2]);
      break;
    case 'q':
      newQ = atof(&argv[i][2]);
      break;
    case 'u':
      mesh = 1;
      break;
    case 's':
      solver = atoi(&argv[i][2]);
      break;
    case 'f':
      inputPath = string((const char*) (&argv[i][2]));
      break;
    case 'T':
      equilTime = (double) atof(&argv[i][2]);
      break;
    case 'a':
      x2axis = (double) atof(&argv[i][2]);
      break;
    case 'x':
      x2edge = (double) atof(&argv[i][2]);
      break;
    case 'A':
      akima = 1;
      break;
    case 'P':
      np1 = atoi(&argv[i][2]);
      break;
    case 'R':
      nr = atoi(&argv[i][2]);
      break;
    case 'E':
      separatrix = (double) atof(&argv[i][2]);
      break;
    case 'h':
      usage();
      exit(1);
      return 0;
    case 'p':
      /* The machinery to have a full alfmsh vector is left in place, in 
         case it comes of interest to set the vector.  Though, this would
         not be of the standard mu power law study. Note that the number of
         resonant surfaces is not known here, so the edge element is moved 
         later in the setalfmsh routine to the correct index, after all is 
         read in. */
      j = 2;
      k = 1;
      alfmsh[0] = atof(&argv[i][j]);
      asin_len = 1;
      while (argv[i][j] != '-' && argv[i][j] != '\0' &&
            k < pest3_asinmax){
        if(flag_loc==0 && argv[i][j]==' ') flag_loc=1;
        if(flag_loc==1 && argv[i][j]!=' ' && k<pest3_asinmax){
          alfmsh[k] = atof(&argv[i][j]);
          flag_loc = 0;
          k++;
        }
        j++;
      }
      asin_len = k;
      if (asin_len==1) {
        // if one number then alfmsh[1] is also set to this number
        alfmsh[1] = alfmsh[0];
      }
      // check the length of alfmsh later after all parameters read in
      break;
    case 'K':
         /* Note that the number of resonant surfaces is not known here, so 
            length of the vector is checked later. */
      j = 2;
      k = 1;
      packpts[0] = atoi(&argv[i][j]);
      pkin_len = 1;
      while (argv[i][j] != '-' && argv[i][j] != '\0' &&
            k < pest3_wsinmax){
        if(flag_loc==0 && argv[i][j]==' ') flag_loc=1;
        if(flag_loc==1 && argv[i][j]!=' ' && k<pest3_wsinmax){
          packpts[k] = atoi(&argv[i][j]);
          flag_loc = 0;
          k++;
        }
        j++;
      }
      pkin_len = k;
      if (pkin_len==1) {
        // if one number then all surfs get this number
        for (k=1;k<pest3_wsinmax;k++) packpts[k] = packpts[0];
      }
      break;
    case 'M':
      packmth = atoi(&argv[i][2]);
      break;
    case 'W':
      j = 2;
      k = 1;
      widmsh[0] = atof(&argv[i][j]);
      wsin_len = 1;
      while (argv[i][j] != '-' && argv[i][j] != '\0' &&
            k < pest3_wsinmax){
        if(flag_loc==0 && argv[i][j]==' ') flag_loc=1;
        if(flag_loc==1 && argv[i][j]!=' ' && k<pest3_wsinmax){
          widmsh[k] = atof(&argv[i][j]);
          flag_loc = 0;
          k++;
        }
        j++;
      }
      wsin_len = k;
      if (wsin_len==1) {
        // if one number then all widmsh are set to this number
        for(j=1; j<pest3_wsinmax; j++) widmsh[j] = widmsh[0];
      }
      // check the length of widmsh later after all parameters read in
      break;
    default:
      std::cerr << pest3_inputError << std::endl;
      usage();
      return (++nErrors);
    }
  }
      return nErrors;
  }

int pest3::checkArgs(void){
  int mm_min = mm[0];
  int i;
  int nsin=0;
  for(i=1; i<pest3_kmax; i++){
    if(mm[i] < mm_min && mm[i]!=0) mm_min = mm[i];
  }

  // The number of resonant surfaces specified
  for (i=0; i<msin_len; i++) {
    if (msin[i]==1) nsin++;
  }

  switch(packmth){
    case 0:
      if(wsin_len!=1 && wsin_len!=nsin+2){
        std::cerr << pest3_inputError << " widmsh must be either length 1 or msin_len+2: " << wsin_len << " " << msin_len << std::endl;
        return (++nErrors);
      } else if(pkin_len!=1 && pkin_len!=msin_len){
        std::cerr << pest3_inputError << " packpts must be either length 1 or msin_len: " << pkin_len << " " << msin_len << std::endl;
        return (++nErrors);
      } 
      break;
    case 1:
      if(wsin_len!=1 && wsin_len!=nsin+2){
        std::cerr << pest3_inputError << " widmsh must be either length 1 or nsin+2: " << wsin_len << " " << nsin << std::endl;
        return (++nErrors);
      } else if(pkin_len!=1 && pkin_len!=nsin){
        std::cerr << pest3_inputError << " packpts must be either length 1 or nsin: " << pkin_len << " " << nsin << std::endl;
        return (++nErrors);
      } 
      break;
    case 2:
      if(wsin_len!=1 && wsin_len!=nsin+2){
        std::cerr << pest3_inputError << " widmsh must be either length 1 or nsin+2: " << wsin_len << " " << nsin << std::endl;
        return (++nErrors);
      } else if(pkin_len!=1 && pkin_len!=nsin){
        std::cerr << pest3_inputError << " packpts must be either length 1 or nsin: " << pkin_len << " " << nsin << std::endl;
        return (++nErrors);
      } 
      break;
    default:
      std::cerr << "ERROR: -M" << packmth << " not handled." << std::endl;
      usage();
      return (++nErrors);
  }

  if(ms < 0){
    std::cerr << pest3_inputError << " resonant poloidal mode number " << ms << " < 1 \n";
    return (++nErrors);
  } else if(n < 1){
    std::cerr << pest3_inputError << " toroidal mode number " << n << " < 1 \n";
    return (++nErrors);
  } else if(mm_min < 5){
    std::cerr << pest3_inputError << " min number of radial nodes " << mm_min << " < 5 \n";
    return (++nErrors);
  } else if(lmax1 < 1){
    std::cerr << pest3_inputError << " max poloidal Fourier mode " << lmax1 << " < 1 \n";
    return (++nErrors);
  } else if(b < 0.0){
    std::cerr << pest3_inputError << " negative wall distance " << b << std::endl;
    return (++nErrors);
  } else if(betmsh < 0.0){
    std::cerr << pest3_inputError << " negative edge packing exponent " << betmsh << std::endl;
    return (++nErrors);
  } else if(asin_len!=1 && asin_len!=2){
    std::cerr << pest3_inputError << " alfmsh must be either length 1 or 2: " << asin_len << std::endl;
    return (++nErrors);
  } else if(dlayb < 1.0e-10 || dlayb > 0.99){
    std::cerr << pest3_inputError << " large solution support " << dlayb << 
      " outside [0.05, 0.99]\n";
    return (++nErrors);
  } else if(dlay < 1.0e-10 || dlay > 0.99){
    std::cerr << pest3_inputError << " large solution support " << dlay <<
      " outside [0.00001, 0.99]\n";
  } else if(inputFormat < -1 || inputFormat > 8){
    std::cerr << pest3_inputError << " Wrong equilibrium input format " << inputFormat << std::endl;
    return (++nErrors);
  } else if(x2axis > 0.5 || x2axis < 0.){
    std::cerr << pest3_inputError << " Extrapolation to axis fraction too large or negative " 
	 << x2axis << " > 0.5\n";
  } else if(x2edge > 0.5 || x2edge < 0.){
    std::cerr << pest3_inputError << " Extrapolation to edge fraction too large or negative " 
	 << x2edge << " > 0.5\n";
  } else if(np1 < 17){
    std::cerr << pest3_inputError << " Number of poloidal contouring points too small " 
	 << np1 << " < 17\n";
  } else if(nr < 11){
    std::cerr << pest3_inputError << " Number of radial contouring points too small " 
	 << nr << " < 11\n";
  } else if(separatrix > 1. || separatrix < 0.1){
    std::cerr << pest3_inputError << " Separatrix retreat factor should be close to <=1 " 
	 << separatrix << std::endl;
  } 
  else{
    return nErrors;
  }
  return nErrors;
}

int pest3::isQsInPlasma(void){

  pstgetqbounds_(&q0, &qa, &qmin, &qmax);
  std::cout << " Equilibrium q axis/edge-> " <<  q0   << '/' << qa << std::endl;
  std::cout << " Equilibrium q min /max -> " << qmin << '/' << qmax << std::endl;

  if(ms != 0){
    double qs =  (double) ms/ (double) n;
    if( qs < qmin || qs > qmax ){
      std::cerr << pest3_execError << " No " << ms << "/" << n << " resonance \n";
      ++nErrors;
    }
  } else {
    if( qmax < qmin + 1.0/double(n) ){
      std::cerr << pest3_execError << " No resonant surface \n";
      ++nErrors; 
    }
  }
    
  return nErrors;
}


int pest3::run(void){

    
  /* Initialize pest3. This step involves reading the equilibrium input
     file in. */

    int i,nsin;

    int nmeshMax = mm[0];
    for(i=1; i<pest3_kmax; i++){
      if(mm[i] > nmeshMax) nmeshMax=mm[i];
    }
    // The number of resonant surfaces specified
    nsin=0;
    for (i=0; i<msin_len; i++) {
      if (msin[i]==1) nsin++;
    }

    int ier;
    long long_len = (long) inputPath_len; // pass string length as last arg
    inputPath_len = (int) inputPath.length();
    pstinit_(&lmax1, &nmeshMax, &inputFormat, 
	     (char *)inputPath.c_str(), &inputPath_len, &equilTime, 
	     &newQ, &akima, &x2axis, &x2edge, &np1, &nr, &separatrix, 
	     &ier,
	     long_len);
    if(ier != 0){
      std::cerr << pest3_execError << " Failed to initialize PEST3\n";
      std::cerr << " There can be several reasons for this to occur\n";
      std::cerr << " 1. Check that the input file/MDSPlus path exists and is valid\n";
      std::cerr << " 2. Check that the plasma is NOT Mercier unstable\n";
      return ++nErrors;
    }

    double gserror;
    pstgetgsaverageerror_(&gserror);
    std::cout << " Average Grad Shafranov solution error->" << gserror << std::endl;
    if(fabs(gserror) > 0.001){
      std::cout << " *WARNING* inaccurate equilibrium\n";
    }
//      if(fabs(gserror) > 0.01){
//        std::cout << " *ERROR* inaccurate MHD equilibrium solution \n";
//        return (++nErrors);
//      }

    /* set input pest3 parameters */

    //int one = 1;
    pstsetn_(&n);
    if( isQsInPlasma() != 0 ){
      return (++nErrors);
    }
    
    /* set the msin variable in pest3, which selects the resonant 
       rational surfaces counting from the axis towards the edge.
       For instance, msin = [0, 1, 0, ..] selects the second rational
       surface. For simplicity, the q profile is assumed monotonic. */
    
    pstsetmsin_(&msin_len, &msin[0]); 

    /* mm, the number of radial nodes, can in general be an array,
       which is useful for performing convergence studies.  */

    int kdim = (int) pest3_kmax;
    pstsetmm_(&kdim, &mm[0]);
    
    pstsetpackmth_(&packmth);

    /* note the max size of packpts is used */
    pstsetpackpts_(&msin_len,&packpts[0]);

    pstsetb_(&b);
    pstsetdlayb_(&dlayb);
    pstsetdlay_(&dlay);
    pstsetlsymhi_(&lsymhi);
    pstsetbetmsh_(&betmsh);

    pstsetalfmsh_(&nsin,&alfmsh[0]);

    int wdim = (int) pest3_wsinmax;
    pstsetwidmsh_(&wdim,&widmsh[0]); 

    pstsetisolver_(&solver);
    pstsetuniformmesh_(&mesh);

    /* run Pest3 */
    pstexec_();

    pstgetmth_(&mth);
    pstgetnosurf_(&nosurf);
    pstgetbetapoloidal_(&betaPoloidal);
    pstgetbetatoroidal_(&betaToroidal);
    pstgettroyong_(&TroyonG);
    pstgetfourpiinductance_(&fourPiInductance);
    pstgettotaltoroidalcurrent_(&totalToroidalCurrent);
    pstgetmajorradius_(&majorRadius);
    pstgetminorradius_(&minorRadius);
    pstgetelongation_(&elongation);
    pstgettriangularity_(&triangularity);
    pstgetb0squarecentre_(&b0SquareCentre);
    pstgetrmagnetic_(&rMagnetic);
    pstgetwlambda_(&wLambda);

    /* layer data */

    pstgetnosing_(&nosing);

    double *twoMuF = new double[pest3_nosingmax];

    pstgetcmatch_(&nosing, &twoMuF[0]);
    pstgetpsisin_(&nosing, &psi0, &psis[0], &psia);
    pstgetxmu_(&nosing, &mu[0]);
    pstgetxsmnus_(&nosing, &lambdas[0]);
    pstgetrsnorm_(&nosing, &rdpdr[0]);
    pstgetdrlay_(&nosing, &dr[0]);
    pstgetqslay_(&nosing, &qs[0]);
    

    /* Delta'. Gamma' etc.. */

    pstgetdelpr_((int *) &pest3_nosingmax, &nosing, 
		 &re_deltap[0][0], &im_deltap[0][0]);
    pstgetgampr_((int *) &pest3_nosingmax, &nosing, 
		 &re_gamtap[0][0], &im_gamtap[0][0]);
    pstgeterror_delpr_((int *) &pest3_nosingmax, &nosing, &err_deltap[0][0]);
    pstgeterror_gampr_((int *) &pest3_nosingmax, &nosing, &err_gamtap[0][0]);


    /* get the log terms */

    double *re_xiLog = new double[pest3_nosingmax];
    double *im_xiLog = new double[pest3_nosingmax];
    pstgetxilogterm_(&nosing, &re_xiLog[0], &im_xiLog[0]);
      

    /* Normalize to psi^(2 mu) etc. */

    for(i = 0; i < nosing; i++){
      if(mu[i] != 0.5) {
	lambdas[i] *= -(1.0-2.*mu[i]); 
      } else {
	lambdas[i] = re_xiLog[i];
      }
      lambdas[i] *= twoMuF[i]*psis[i];

      rdpdr[i] /= (twoMuF[i]*pow(psis[i], 2.0*mu[i]));
      for(int j = 0; j < nosing; j++){
	double fact = sqrt(twoMuF[i]*twoMuF[j]) 
	  * pow(psis[i], mu[i]) 
	  * pow(psis[j], mu[j]);
	re_deltap[i][j] *= fact;
	im_deltap[i][j] *= fact;
	err_deltap[i][j] *= fact;
	re_gamtap[i][j] *= fact;
	im_gamtap[i][j] *= fact;
	err_gamtap[i][j] *= fact;
      }
    }

    delete[] twoMuF;
    delete[] re_xiLog;
    delete[] im_xiLog;
    
    // nodes where ideal instability, if any, was detected
    int dum;
    int zero = 0;
    pstgetineg_(&nIdealInstabilities, &dum, &zero);
    if (wLambda != 0.0){
      std::cout << " delta-W eigenvalue " << wLambda << std::endl;
    }
    if (nIdealInstabilities != 0){
      // get the nodes where the instability occurs
      int nsize=nIdealInstabilities;
      int *nodes = new int[nsize];
      pstgetineg_(&nIdealInstabilities, &nodes[0], &nsize);
      std::cout << " *WARNING*: " << nsize << " ideal instabilities detected at nodes ";
      for(i=0; i<nsize; i++){
	std::cout << nodes[i] << ' ';
      }
      std::cout << '\n';
      delete[] nodes;
    }


    /* free memory */

    pstfree_();

    return nErrors;
}
    
#endif /* __pest3__ */
